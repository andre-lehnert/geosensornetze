\chapter{Simulationsumgebung}
\label{cha:simulationsumgebung}

Das Kapitel der Simulationsumgebung befasst sich mit den Eingabemöglichkeiten zur Anpassung der Simulationsparameter, sowie der konkreten Umsetzung der simulierten Welt, mit der Logik für die Notausgänge, der Personen, der Gefahrensituationen und dem Kommunikationsmodell.

Die Ausgangsbasis für die verwendeten Modelle und Protokolle stammen aus den erstellten Übungen zur Vorlesung Gensensornetze, sie wurden jedoch auf die Anforderungen der Hausarbeit adaptiert.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Benutzerschnittstelle}
\label{sec:benutzerschnittstelle}

In diesem Abschnitt werden die Interaktions- und Konfigurationsmöglichkeiten mit der Simulationsumgebung erläutert. Abbildung \ref{fig:gui} stellt einen Ausschnitt des grafischen Interfaces von NetLogo da, anhand dessen die Erklärungen in den folgenden Abschnitten besser einzuordnen sind. 

\begin{figure}[!ht]
\centering
\includegraphics[height=0.85\textwidth]{simulationsumgebung/gui_3}
\caption{Grafische Oberfläche}
\label{fig:gui}
\end{figure}

\subsection{Benutzerevents}
\label{sec:gui_userevents}

Zum Auslösen von Benutzerevents werden Buttons verwendet. Zu diesen zählen \verb|setup|, \verb|reset| und \verb|go|, die hier kurz beschrieben werden.

\subsubsection*{setup-Button}

Die Betätigung des \verb|setup|-Buttons ruft eine Folge von Setup und Initialisierungsschritten auf. Zu Beginn wird die Simulationswelt erstellt. Dazu wird der Parameter \verb|inputFile| (siehe Abschnitt \ref{sec:gui_general}) zum Einbinden einer Bild-Datei und das Mapping der Pixel-Farbwerte auf die passend skalierte NetLogo-Welt gemappt. Das Ergebnis ist der gewählte Grundriss, bei dem jedes Patch einen Farbwert erhalten hat.

Dieser Farbwert ist essentiell für den nachfolgenden Schritt in der \verb|setup-patches|-Methode. Diese legt den Initialzustand jedes Patches fest (siehe Abschnitt \ref{sec:patches}). Generell wird auf Grund des Grundrisses zwischen leerem Raum (weiß) und einer Wand unterschieden (schwarz). 

Wände spielen auch bei der Initialisierung und Platzierung der Notausgänge eine wichtige Rolle, die mit der \verb|setup-exits|-Methode realisiert sind. Entsprechend der Aufgabenstellung werden Notausgänge auf einem abstrakten Grundriss, ohne Wände, zufällig in der Welt platziert. Für alle anderen Grundrisse mit Wänden wurde auf statische vordefinierte Positionen für Notausgänge gesetzt.\par
Bei der Initialisierung wird zudem die lokale Konstante der maximalen Signalreichweite für den Orientierungsalgorithmus \emph{cellular automaton} mit dem Parameter \verb|exit-signal-strength| aus Abschnitt \ref{sec:gui_exit} gesetzt und alle Notausgänge in den Zustand \emph{INIT} versetzt (vgl. Abschnitt \ref{sec:notausgaenge}).\par
Im Anschluss wird der \emph{cellular automaton}-Algorithmus (siehe Abschnitt \ref{sec:cellular_automaton}) ausgeführt, um die Patches mit Signalqualitätsinformationen auszustatten, damit die Personen den optimalen Fluchtweg bei einer Gefahrensituation nutzen.

Nachdem die Simulationswelt mit den statischen Elementen vorbereitet wurde, werden die Personen initialisiert und platziert. Dies geschieht mit der Methode \verb|setup-persons|. Hier wird eine definierte Anzahl von Personen erstellt (siehe Abschnitt \ref{sec:gui_person}, die auf einem abstrakten Grundriss zufällig und auf allen anderen zufällig mit einer Wand-Detektion platziert werden. Die Personen befinden sich nun im Zustand \emph{INIT} (vgl. Abschnitt \ref{sec:bewegungsmodell}).\par
Nach der Platzierung wird einmalig ein Kommunikationsgraph zwischen den Personen und den Notausgängen erstellt, damit der Nutzer ggf. den Graph-Typen oder die Kantenlänge anpassen kann (siehe Abschnitt \ref{sec:gui_person}).
 
Als letzter Schritt folgt die Initialisierung und Platzierung der Gefahrenevents  mittels \verb|setup-events|. Die analog zu den Personen auf dem abstrakten Grundriss zufällig und bei allen anderen Grundrissen mit Wand-Detektion platziert werden. Danach befinden sich alle Gefahrenevents im Zustand \emph{INIT} (vgl. Abschnitt \ref{sec:gefahrensituationen}).
 
\subsubsection*{reset-Button}

Mit dem \verb|reset|-Button werden alle definierten Parameter des letzten Setups wiederhergestellt und die Personen auf ihre ursprüngliche Position zurückgesetzt.
Ein fluten des Grundrisses ist nicht erforderlich und beschleunigt das durchführen von Messreihenreihen.
Zudem bietet es die Möglichkeit den Kommunikationsgraphen der Personen auszublenden, dies ist unter anderem nützlich bei der Darstellung der initial approximierten Positionen der Personen.

\subsubsection*{go-Button}

Schließlich kann die Simulation mit dem \verb|go|-Button gestartet und pausiert werden, da hier die \emph{forever}-Option aktiv ist. Ist diese deaktiviert, wird pro Betätigung des \verb|go|-Buttons nur ein \emph{Tick} durchgeführt.

\subsection{Generelle Parameter}
\label{sec:gui_general}

Der Parameter \verb|input-file| erlaubt die Definition des Grundrisses der Simulationsumgebung. Während des Setups wird der Parameter zur Pfadauflösung für eine Bild-Datei verwendet. Diese wird mit dem Befehl \verb|import-pcolors inputFile| auf die Simulationswelt gemappt.

\begin{quote}
\verb|input-file| $\in \{Abstract.png, Abstract\_static.png, Simple.png,$ \\\hspace*{2.6cm}$Raumplan.png\}$
\end{quote}

Der nächste generelle Parameter ist \verb|orientation-algorithm|. Dieser dient der Auswahl eines Algorithmus zur Orientierung und Lokalisierung der Personen. Detaillierte Informationen sind im Kapitel \ref{cha:algorithmik} aufgeführt.

\begin{quote}
\verb|orientation-algorithm| $\in \{Cellular$ $automaton, Gradient$ $localization\}$
\end{quote}

Mit dem \verb|graph-type|-Parameter hat der Nutzer die Wahl zwischen den Graphtypen, die in der Vorlesung vorgestellt wurden. Sofern \emph{UDG} gewählt ist, wird der \verb|person-detection-radius|-Parameter des folgenden Abschnitts für den Disk-Radius verwendet.

\begin{quote}
\verb|graph-type| $\in \{Complete$ $Graph, UDG, RNG, GG\}$
\end{quote}

\subsection{Personen--Parameter}
\label{sec:gui_person}

\verb|person-count| definiert die Anzahl der Personen in der Simulationsumgebung.

\begin{quote}
\verb|person-count| $\in [1, 300]$
\end{quote}

Mit dem \verb|walk-probability|-Parameter wird die Wahrscheinlichkeit definiert, mit der Personen bei einem Tick einen Schritt machen. Bei $0 \%$ werden die Personen statisch an der gegenwärtigen Position fixiert. Es ist also möglich diesen Parameter während der Laufzeit zu verändern.  

\begin{quote}
\verb|walk-probability| $\in [0, 100]$
\end{quote}

Der \verb|walk-strategy|-Parameter erlaubt die Auswahl der \emph{random walk}-Strategie (siehe Abschnitt \ref{sec:bewegungsmodell}).

\begin{quote}
\verb|walk-strategy| $\in \{Complete$ $random, Straight$ $with$ $collision$ $detection,$\\\hspace*{3.2cm}$Straight$ $with$ $probability\}$
\end{quote}

Analog zur \verb|walk-probability| kann der Nutzer den \verb|random-walk-probability|-Parameter zur Laufzeit anpassen und somit die Wahrscheinlichkeit der \emph{random walk} Richtungsänderung bestimmen. Bei $100 \%$ wird jede Person nach jedem Tick eine Richtungsänderung vornehmen.

\begin{quote}
\verb|random-walk-probability| $\in [0, 100]$
\end{quote}

Der \verb|person-detection-radius|-Parameter ist einer der entscheidendsten bei der Simulation. Hiermit wird der Radius definiert in dem eine Person eine Gefahrensituation wahrnehmen kann, sowie die Kommunikationsreichweite bei dem UDG-Graphen bestimmt. Zudem wird damit der Abstand zu einem Notausgang bestimmt (siehe Kapitel \ref{cha:algorithmik}.

\begin{quote}
\verb|person-detection-radius| $\in [0, 700]$
\end{quote}



\subsection{Event--Parameter}
\label{sec:gui_event}

Mit dem Parameter \verb|event-count| wird die Anzahl der zu platzierenden Gefahrenevents festgelegt. Bei \verb|event-count|$ = 0$ wird es zu keiner Gefahrensituation kommen, sodass der random-walk getestet werden kann.

\begin{quote}
\verb|event-count| $\in [0, 20]$
\end{quote}

In der Aufgabenstellung wird ein zufälliges Auslösen von Gefahrensituationen gefordert, die beiden Parameter \verb|min-countdown| und \verb|max-countdown| bewerkstelligen dies. Jedes einzelne Gefahrenevent erhält zufällig einen initialen Countdown im Intervall $[$\verb|min-countdown|, \verb|max-countdown|$]$. Die obere bzw. untere Intervallgrenze der Parameter wird durch den jeweils anderen Parameter eingeschränkt.  

\begin{quote}
\verb|min-countdown| $\in [1, $\textit{max-countdown}$]$
\end{quote}

\begin{quote}
\verb|max-countdown| $\in [$\textit{min-countdown}$, 100]$
\end{quote}

Der Parameter \verb|gas-expansion-probability| legt für alle Gefahrenevents die Ausbreitungswahrscheinlichkeit und somit die Ausbreitungsgeschwindigkeit fest. Bei $0 \%$ wird nur genau ein Patch unter dem jeweiligen Gefahrenevent zu einer Bedrohung für die Personen. Personen können die Gefahrensituationen somit wahrnehmen, die Wahrscheinlichkeit das Personen sterben ist jedoch sehr gering. 

\begin{quote}
\verb|gas-expansion-probability| $\in [0, 100]$
\end{quote}


\subsection{Notausgang--Parameter}
\label{sec:gui_exit}

Der Parameter zur Einstellung der verfügbaren Notausgänge in der simulierten Welt, 
\verb|number-of-exits| ist sehr bedeutsam bei der Lokalisierungsgenauigkeit und dem Fluchtverhalten der Personen.

\begin{quote}
\verb|number-of-exits| $\in [1, 9]$
\end{quote}

Zur dezentralen Orientierung der Personen und Schaffung eines optimalen Fluchtweges, wird auf den Zellulären Automaten zurückgegriffen und die Patches mit Informationen zur Signalstärke jedes Notausganges versehen.\par
Der Parameter \verb|exit-signal-strength| bildet die maximale Signalstärke bzw. Reichweite der Notausgänge ab. Es ist möglich, dass nicht jedes Patch mit allen Signalinformationen versehen ist, da die Reichweite eines Notausganges zu gering war.

\begin{quote}
\verb|exit-signal-strength| $\in [0, 1000]$
\end{quote}

Die Aufgabenstellung fordert eine Limitierung Fluchtkapazitäten von Notausgängen. D.h. Notausgänge können maximal \verb|exit-limit| Personen pro Tick evakuieren, sonst werden sie blockiert.

\begin{quote}
\verb|exit-limit| $\in [1, 300]$
\end{quote}

\subsection{Gradient localization--Parameter}
\label{sec:gui_localization}

- - - - - - - - - - - - - - - - - - - - - \\
TODO: Marcell Beschreibung der Parameter, Bedeutung\\
- - - - - - - - - - - - - - - - - - - - - \\

\verb|locate-iterations|

\begin{quote}
\verb|locate-iterations| $\in [0, 100]$
\end{quote}

\verb|approx-dist|

\begin{quote}
\verb|approx-dist| $\in [0, 200]$
\end{quote}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Personen}
\label{sec:personen}




% Lifecycle
\subsection{Zustände}

% INIT
% INIT, DEAD
% INIT, RESCUED
% INIT, EVENT_DETECTED, DEAD
% INIT, EVENT_DETECTED, FLEEING, RESCUED
% INIT, EVENT_DETECTED, FLEEING, DEAD

\begin{figure}
\centering
\includegraphics[height=0.6\textwidth]{simulationsumgebung/person.eps}
\caption{Zustandsdiagramm der Personen}
\label{fig:person}
\end{figure}

\subsection{Bewegungsmodell}
\label{sec:bewegungsmodell}
%Bewegungsmodell: Die Agenten sollen sich nach einem „Random Walk“ Modell bewegen. Agenten können Gefahren in ihrer Umgebung wahrnehmen und die Information an ihre nächs-ten Nachbarn weitergeben. Sobald ein Agent Informationen über eine Gefahrensituation hat, soll er sich auf dem kürzesten Weg zum nächsten Notausgang bewegen.  Hat ein Agent die Umgebung eines Notausgangs erreicht, soll er aus der Simulation genommen werden.

Dieser Abschnitt beschreibt zunächst das Bewegungsmodell der Personen ohne aktive Gefahrensituation.

\floatname{algorithm}{Algorithmus} 
\begin{algorithm}
\caption{random-walk}
\begin{algorithmic} 
\STATE nb $\leftarrow$ one-of neighbors
\WHILE{\textit{[patch-state] of nb = WALL}}
\STATE nb $\leftarrow$ one-of neighbors 
\ENDWHILE
\STATE face nb
\STATE forward 1
\end{algorithmic}
\end{algorithm}


\subsection{Kommunikationsmodell}
\label{sec:kommunikationsmodell}
%Kommunikationsmodell: Als Kommunikationsmodell können beliebige Modelle der Vorlesung implementiert werden. Dabei sollte insbesondere auf die dynamische Netzwerktopologie geach-tet werden. 

\floatname{algorithm}{Protokoll} 
\begin{algorithm}
\caption{Warnung vor Gefahrensituationen}
\begin{algorithmic} 
\STATE \textit{State Trans. Sys.:} $\langle\{$INIT, EVENT{\_}DETECTED, FLEEING, RESCUED, DEAD$\}\rangle$
\STATE \textit{Initialization:} All notes in state INIT
\STATE \textit{Restrictions:} Reliable communication; connected, bidirected communication graph $G = (V,E)$, neighborhoodfunction nbr: $V \rightarrow 2^{V}$
\STATE \textit{Local data:}

\STATE $ $
\STATE \textbf{INIT}
\STATE Receiving(\textit{event{\_}detected})
\WHILE{\textit{not event{\_}detected}}
\STATE random-walk
\STATE create-graph($G$)\hfill\emph{; generate complete new graph}
\ENDWHILE
\STATE become EVENT{\_}DETECTED


\STATE $ $
\STATE \textbf{EVENT{\_}DETECTED}
\STATE broadcast(\textit{event{\_}detected})\hfill\emph{; broadcast event detection to linked neighbors}
\STATE become FLEEING

\STATE $ $
\STATE \textbf{FLEEING}
\STATE broadcast(\textit{event{\_}detected})\hfill\emph{; rebroadcast event detection to linked neighbors}
\WHILE{\textit{not person-reach-exit}}
\STATE person-move-to-exit\hfill\emph{; using orientation-algorithm}
\STATE create-graph($G$)\hfill\emph{; generate complete new graph}
\IF{touching-gas}
\STATE become DEAD
\ENDIF
\ENDWHILE
\STATE become RESCUED

\STATE $ $
\STATE \textbf{RESCUED}
\STATE create-graph($G$)\hfill\emph{; generate complete new graph without note}

\STATE $ $
\STATE \textbf{DEAD}
\STATE create-graph($G$)\hfill\emph{; generate complete new graph without note}

\end{algorithmic}
\end{algorithm}

\section{Notausgänge}
\label{sec:notausgaenge}
%Notausgänge: Notausgänge sollen als statische Sensorknoten modelliert werden, die ihre Po-sition sowie Information zu ihrer Passierbarkeit im Netz verteilen. Die Positionen dieser sog. anchor nodes sollen zur Positionierung der mobilen Sensorknoten verwendet werden (Algorithmik). Während einer Simulation sollte der Ausfall einzelner Notausgänge simuliert werden.

%Lifecycle
\subsection{Zustände}

% INIT, NEGOTIABLE
% INIT, NEGOTIABLE, BLOCKED

\begin{figure}
\centering
\includegraphics[height=0.6\textwidth]{simulationsumgebung/exit.eps}
\caption{Zustandsdiagramm der Notausgänge}
\label{fig:exit}
\end{figure}

%\begin{algorithm}
%\caption{Patch-Flooding (Zellulärer Automat)}
%\begin{algorithmic} 
%\STATE \textit{State Trans. Sys.:} $\langle\{$NONE$\},\{$NONE, SPREADING, IDLE, DONE$\}\rangle$
%\STATE \textit{Initialization:} All patches in state NONE
%\STATE \textit{Restrictions:} orientation-algorithm = $"$Cellular automaton$"$
%\STATE \textit{Global data:} exit-signal-strength $\in \mathbb{N}_{\geq0}$
%\STATE \textit{Local data:} 
%\STATE Set \textit{exits} of exits in range
%\STATE Set \textit{signal-noises} of exit signals
%
%\STATE $ $
%\STATE \textbf{NONE}
%\STATE \textit{Spontaneously}
%\STATE exits $\leftarrow$ myself\hfill\emph{;exit on this patch}
%\STATE signal-noises $\leftarrow$ 0
%\STATE become SPREADING
%
%
%\STATE $ $
%\STATE \textbf{SPREADING}
%\STATE parent-exit $\leftarrow$ exit
%\STATE signal-noise-here $\leftarrow$ signal-noise + 1
%\FOR{? one-of neighbors}
%\IF{[patch-state] of ? = NONE}
%\STATE exits $\leftarrow$ parent-exit
%\STATE signal-noises $\leftarrow$ signal-noise-here
%\ENDIF
%\ENDFOR
%\STATE become IDLE
%
%
%\STATE $ $
%\STATE \textbf{IDLE}
%
%\STATE become DONE
%
%\STATE $ $
%\STATE \textbf{DONE}
%
%\end{algorithmic}
%\end{algorithm}


\section{Gefahrensituationen}
\label{sec:gefahrensituationen}
%Gefahrenevents: Gefahrenevents erscheinen an zufälligen Orten im Grundriss. Ihr Erscheinen sollte zur vollständigen Evakuierung des Areals führen.

%Lifecyle
\subsection{Zustände}

% INIT, COUNTDOWN, GASSING, DONE

\begin{figure}
\centering
\includegraphics[height=0.6\textwidth]{simulationsumgebung/event.eps}
\caption{Zustandsdiagramm der Gefahrenevents}
\label{fig:event}
\end{figure}

\floatname{algorithm}{Protokoll} 
\begin{algorithm}
\caption{Gefahrensituation}
\begin{algorithmic} 
\STATE \textit{State Trans. Sys.:} $\langle\{$INIT, COUNTDOWN, GASSING, DONE$\}\rangle$
\STATE \textit{Initialization:} All notes in state INIT
\STATE \textit{Restrictions:} All patches in state $\{$NONE, DONE$\}$
\STATE \textit{Local data:} countdown $\in \mathbb{N}_{\geq0}$ 
\STATE $ $
\STATE \textbf{INIT}
\STATE \textit{Spontaneously}

\STATE countdown $\leftarrow$ minCountdown + (random (maxCountdown - minCountdown))
\STATE become COUNTDOWN


\STATE $ $
\STATE \textbf{COUNTDOWN}
\STATE countdown $\leftarrow$ countdown - 1
\IF{$countdown = 0$}
\STATE become GASSING
\ENDIF

\STATE $ $
\STATE \textbf{GASSING}
\STATE ask patch-here $[$ patch-state $\leftarrow$ EVENT $]$ 
\STATE become DONE

\STATE $ $
\STATE \textbf{DONE}

\end{algorithmic}
\end{algorithm}


\section{Patches}
\label{sec:patches}

- Initialisierung der Patches setup-patches
 - Zustandsfestlegung für alle Patches 
  - white -> NONE
  - black -> WALL
  - rest -> WALL
 - Initialisierung der lokalen Daten \verb|signal-noise| abhängig vom Zustand: leerer Raum -> -1, Wand -> sehr hohe Dämpfung \ref{sec:gui_exit} 


%Lifecyle
\subsection{Implizite Zustände}
\label{sec:patch_states}
% NONE, WALL, SPREADING, IDLE, DONE, EVENT, EVENT-DONE

% Kategorie: Grundriss
% NONE
% WALL

% Kategorie: Zellulärer Automat
% NONE
% NONE, SPREADING, IDLE, DONE

% Kategorie: Gefahrensituation
% NONE, EVENT
% NONE, EVENT, EVENT_DONE
% DONE, EVENT
% DONE, EVENT, EVENT_DONE

\begin{figure}
\centering
\includegraphics[height=0.6\textwidth]{simulationsumgebung/patch.eps}
\caption{Zustandsdiagramm der Patches}
\label{fig:patch}
\end{figure}

\section{Ressourcen der Simulationsumgebung}
\label{sec:ressourcen}

Die Simulationsumgebung wird über die Datei \verb|Evakuierung.nlogo| gestartet. Der Programmcode ist nach Funktion und \emph{Breed}-Klasse unterteilt.

\paragraph{Gefahrensituationen} 

\begin{verbatim}
event.nls
event-gassing.nls
\end{verbatim}

Die Quellcode-Datei \verb|event.nls| beinhaltet den Lebenszyklus der Gefahrenevents und deren Zustandsübergangsprotokoll. Mittels \verb|event-gassing.nls| wird die Ausbreitung des Giftgases implementiert, die größtenteils den Patch-Lebenszyklus manipuliert.

\paragraph{Lokalisierung}

\begin{verbatim}
locate.nls
\end{verbatim}

In dieser Datei wird der Algorithmus zur Lokalisierung aus dem Paper \cite{Jonathan.2004} implementiert.

\paragraph{Notausgänge}

\begin{verbatim}
exit.nls
exit-cellular-automaton.nls
exit-gsn.nls
\end{verbatim}

Die Quellcode-Datei \verb|event.nls| steuert den Setup und den Lebenszyklus der Notausgänge. Mittels \verb|exit-cellular-automaton.nls| wird der Orientierungsalgorithmus auf Basis des zellulären Automats realisiert. Letztlich definiert die Datei \verb|exit-gsn.nls| das Kommunikationsmodell zur Übermittlung der Statusinformationen.

\paragraph{Personen}

\begin{verbatim}
person.nls
person-gsn.nls
person-linking.nls
\end{verbatim}

\verb|person.nls| regelt den Setup der Personen und deren Lebenszyklus. \verb|person-gsn.nls| umfasst den Quellcode für die Kommunikation zwischen Personen und mit der Datei \verb|person-linking.nls| wird der Graph zwischen Personen erstellt.

\paragraph{Simulationswelt}

\begin{verbatim}
patch.nls
\end{verbatim}

Hier wird der Quellcode für den Lebenszyklus der \emph{Patches} definiert.