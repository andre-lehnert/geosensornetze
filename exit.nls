;; Exit

__includes["exit-cellular-automaton.nls"]

exits-own [
  messages
  radius
  inner-radius 
  state
  negotiable 
  limit ;; Limitierung der möglichen Personen, die zeitgleich den Ausgang benutzen können
  signal-color
  max-noise
]

to block-random-exit
  let proceed true
  while [proceed] [
    ask one-of exits [
      if state != "BLOCKED" [
        exit-state "BLOCKED"
        set proceed false
      ]
    ]
  ]
end

to exit-state [newstate]
  
  set state newstate
  
  ;; Start
  if state = "INIT" [    
    set size 20
    set shape "square"
    set color yellow
    set heading 0
    set label-color black
  ]
  
  ;; Passierbar
  if state = "NEGOTIABLE" [
    set negotiable true
    set size 20
    set shape "square"
    set color green ;; Falls negotiable = true
    set heading 0
    set label-color black
  ]  
  
  ;; Nicht passierbar
  if state = "BLOCKED" [
    set negotiable false
    set size 20
    set shape "square"
    set color red ;; Falls negotiable = false
    set heading 0
    set label-color black
  ] 
  
end


;; Platzierung der Notausgänge
to setup-exits
  
  ;; x,y für zwei (z.Z. fix) Notausgänge
  let x1 0
  let x2 0
  let x3 0
  let x4 0
  let x5 0
  let y1 0
  let y2 0
  let y3 0
  let y4 0
  let y5 0
  
  if inputFile = "Abstract.png" [ ;; Zufällige Platzierung
    if number-of-exits >= 1 [
      set x1 random-pxcor
      set y1 random-pycor
    ]
    if number-of-exits >= 2 [
      set x2 random-pxcor
      set y2 random-pycor
    ]
    if number-of-exits >= 3 [
      set x3 random-pxcor
      set y3 random-pycor
    ]
    if number-of-exits >= 4 [
      set x4 random-pxcor
      set y4 random-pycor
    ]
    if number-of-exits >= 5 [
      set x5 random-pxcor
      set y5 random-pycor
    ]
  ]
  if inputFile = "Abstract_static.png" [
    if number-of-exits >= 1 [
      set x1 10
      set y1 10
    ]
    if number-of-exits >= 2 [
      set x2 max-pxcor - 10
      set y2 max-pycor - 10
    ]
    if number-of-exits >= 3 [
      set x3 max-pxcor / 2
      set y3 max-pycor / 2
    ]
    if number-of-exits >= 4 [
      set x4 10
      set y4 max-pycor - 10
    ]
    if number-of-exits >= 5 [
      set x5 max-pxcor - 10
      set y5 10
    ]
  ]
  if inputFile = "Simple.png" [ ;; Statische Platzierung
    if number-of-exits >= 1 [
      set x1 20
      set y1 max-pycor - 20
    ]
    if number-of-exits >= 2 [
      set x2 max-pxcor - 20
      set y2 max-pycor - 20
    ]
    if number-of-exits >= 3 [
      set x3 max-pxcor - 20
      set y3 20
    ]    
    if number-of-exits >= 4 [
      set x4 20
      set y4 20
    ]    
    if number-of-exits >= 5 [
      set x5 260
      set y5 20
    ]    
  ]
  if inputFile = "ikg.png" [ ;; Statische Platzierung
    if number-of-exits >= 1 [
      set x1 290
      set y1 330
    ]
    if number-of-exits >= 2 [
      set x2 40
      set y2 510
    ]
    if number-of-exits >= 3 [
      set x3 40
      set y3 510
    ]   
  ]
  if inputFile = "Raumplan.png" [ ;; Statische Platzierung
    if number-of-exits >= 1 [
      set x1 290
      set y1 330
    ]
    if number-of-exits >= 2 [
      set x2 0
      set y2 510
    ]
    if number-of-exits >= 3 [
      set x3 610
      set y3 510
    ]   
    if number-of-exits >= 4 [
      set x4 22
      set y4 26
    ]   
    if number-of-exits >= 5 [
      set x5 max-pxcor - 30
      set y5 26
    ]   
  ]
  
  if number-of-exits >= 1 [
    create-exits 1 [
      setxy x1 y1
      set signal-color cyan
    ]
  ]
  if number-of-exits >= 2 [
    create-exits 1 [
      setxy x2 y2
      set signal-color orange
    ]
  ]
  if number-of-exits >= 3 [
    create-exits 1 [
      setxy x3 y3
      set signal-color blue
    ]
  ]
  if number-of-exits >= 4 [
    create-exits 1 [
      setxy x4 y4
      set signal-color black
    ]
  ]   
  if number-of-exits >= 5 [
    create-exits 1 [
      setxy x5 y5
      set signal-color grey
    ]
  ]   
  
  
  ask exits [    
    exit-state("INIT")
    
    set messages []
    set limit exitLimit
    
    set radius 600 
    set inner-radius 1 
    set max-noise exit-signal-strength   
  ]
  
  init-orientation-algorithm  
  
end


to reset-exits
  ask exits [    
    exit-state "NEGOTIABLE"
  ]
end


to init-orientation-algorithm
  
  if orientation-algorithm = "Cellular automaton" [
    init-decentral-signal-spreading
    decentral-signal-spreading
  ]
  
  if orientation-algorithm = "Gradient localization" [
    locate-persons
  ]
  
  ask exits [    
    exit-state "NEGOTIABLE"
  ]
  
end


to hide-signal-spreading
  
  ask patches [
    
    if ( pcolor = orange or pcolor = cyan or pcolor = blue ) [
      set pcolor white 
    ]  
    
  ]
  
end









to-report is-available [x y x0 y0]
  
  if (is-world x y x0 y0) [  
    if (is-wall x y x0 y0) [
      report false 
    ]
    report true
  ]
  
  report false
  
end

to print-signal-spreading
  
  if (show-signal-spreading) [ 
    ;let patch-color 0 
    ;ask nearest-exit [ set patch-color signal-color ]
    ;set pcolor patch-color  ;; <- Farbwahl 1: Zugehörigkeit
    
    ;; Farbwahl 2: Abstand
    if (signal-noise > 0) [
      set pcolor 54
    ]
    if (signal-noise > 100) [
      set pcolor 56
    ]
    if (signal-noise > 200) [
      set pcolor 65
    ]
    if (signal-noise > 300) [
      set pcolor 46
    ]
    if (signal-noise > 400) [
      set pcolor 44
    ]
    if (signal-noise > 500) [
      set pcolor 26
    ]
    if (signal-noise > 600) [
      set pcolor 16
    ]
    if (signal-noise > 700) [
      set pcolor 15
    ]
    if (signal-noise > 800) [
      set pcolor 14
    ]
    if (signal-noise > 900) [
      set pcolor 13
    ]
    if (signal-noise > 1000) [
      set pcolor 12
    ]
    if (signal-noise > 1100) [
      set pcolor 11
    ]
    
  ]
  
end


to-report is-world [x y x0 y0]
  
  set x x + x0
  set y y + y0
  
  let in (x > 0 and y > 0) and (x < max-pxcor and y < max-pycor)
  
  report in
  
end


to-report is-wall [x y x0 y0]
  
  let wall false
  
  
  ask patch-at x y [  
    if (pcolor != white and pcolor != orange) [         
      set wall true
    ]
  ] 
  
  report wall
  
end


to exit-blocked
  if state = "BLOCKED" [
    broadcast (list "EXIT_BLOCKED" who)
  ]
end

to connect-exit
  let exit-n 0
  let nearest-neighbor 0
  foreach sort exits [
    let exit ?
    foreach filter [[distance exit] of ? <= person-detection-radius] sort persons [
      if [state] of ? != "DEAD" [
        ask exit [create-comm-link-with ?]
      ]
    ]
    set exit-n (exit-n + 1)
  ]
end

