;; Person

persons-own [
  state ;; Status im Lebenszyklus 
  messages
  parent 
  children 
  msgsent 
  msgrecv 
  msghear
  exit-hopcounts
  exit-positions
  est-pos
  last-random-heading
]

to person-state [newstate]
  
  set state newstate
  
  ;; Start
  if state = "INIT" [
    set size 15
    set shape "person"
    set color brown
    set heading 0
    set label-color black
    set label ""    
    set exit-hopcounts array:from-list n-values number-of-exits [-1]
    set exit-positions array:from-list n-values number-of-exits [-1]
    set est-pos (list -1 -1)
    set last-random-heading 361
  ]
  
  if state = "EVENT_DETECTED" [
    set label "!"
  ]  
  
  if state = "FLEEING" [
    set label "*"
  ]  
  
  ;; Ende
  if state = "RESCUED" [
    die ;; turtle von der Karte entfernen
  ] 
  
  if state = "DEAD" [
    set color grey    
    set shape "person_dead" ;; selbsterstellte Shape: rotierbar
    set heading 45
    set label ""   
  ]
  
end

to reset-persons
  
  clear-links
  clear-persons  
  
  let i 0
  while [i < array:length reset-params] [
    create-persons 1 [
      person-state "INIT"
      setxy (item 0 array:item reset-params i) (item 1 array:item reset-params i)  
    ]
    set i i + 1
  ]
  
  ask persons [
    
    set messages[] ;; Clear any messages
    set msgsent [] ;; Clear the list of messages sent
    set msgrecv [] ;; Clear the list of messages received
    set msghear []
    
    person-state "INIT"   
    
  ]
  
end

to clear-persons
  
  ask persons [ 
    
    set messages[] ;; Clear any messages
    set msgsent [] ;; Clear the list of messages sent
    set msgrecv [] ;; Clear the list of messages received
    set msghear []
    die 
    
  ]
  
end

;; Zufällige Platzierung von Personen
to setup-persons
  
  if inputFile = "Abstract.png" [ ;; Zufällige Platzierung
    create-persons personCount [
      setxy random-pxcor random-pycor     
    ]
  ]
  if inputFile = "Abstract_static.png" [ ;; Zufällige Platzierung
    place-persons
  ]
  if inputFile = "Simple.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ]
  if inputFile = "ikg.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ]
  if inputFile = "Raumplan.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ] 
  
  ;; Verlinkung aller Personen, Kommunikation wird per Distance eingeschränkt
  create-graph
  
  ask persons [
    
    set messages[] ;; Clear any messages
    set msgsent [] ;; Clear the list of messages sent
    set msgrecv [] ;; Clear the list of messages received
    set msghear []
    
    person-state("INIT")
  ]
  
  
  
end



to place-persons
  
  create-persons personCount [
    
    let y random-pycor
    let x random-pxcor
    
    while [[patch-state] of patch x y = "WALL"] [
      
      set y random-pycor
      set x random-pxcor
      
    ]
    
    setxy x y
    
  ]
  
end

to place-persons-regular [diff]
  
  let y 0
  let x 0    
  
  create-persons personCount [
    
    while [x < max-pxcor and y < max-pycor and [patch-state] of patch x y = "WALL"] [
      
      set y y + diff
      set x x + diff
      
    ]
    
    setxy x y
    set x x + diff
    set y y + diff
  ]
  
end


to random-move
  
  ;; Erhalten der Broadcast Meldung, dass ein event detektiert wurde
  let msg received "EVENT_DETECTED"
  if msg != [] [
    broadcast ["EVENT_DETECTED"]
    ask link-neighbors [ask link-with myself [set color orange]] ;; Link colors are orange
    person-state "EVENT_DETECTED"
    stop
  ]
  
  
  let g random-float 1.00000001 ;; Wahrscheinlichkeit g
  let probability    0.00000001 ;; float initialisieren ?!
  set probability ( walk-propability / 100 )
  
  if g <= probability [
    
    random-walk
  ]  
  
  ;; Person kommt in Kontakt mit dem Giftgas und stirbt
  if [patch-state] of patch-here = "EVENT" or [patch-state] of patch-here = "EVENT-DONE"[
    
    person-state("DEAD")
    
  ]
  
end


to random-walk
  
  if walk-strategy = "Straight with probability" and last-random-heading != 361 [
    
    let g random-float 1.00000001 ;; Wahrscheinlichkeit g
    let probability    0.00000001 
    set probability ( random-walk-probability / 100)
    
    set heading last-random-heading    
   
    if g <= probability [       
      set last-random-heading 361
      random-walk
    ]
    
    change-direction     
  ]
  
  if walk-strategy = "Straight with collision detection" and last-random-heading != 361 [   
    
    set heading last-random-heading    
    change-direction 
    
  ]  
  
  if last-random-heading = 361 [
    let nb one-of neighbors
    
    while [[patch-state] of nb = "WALL"] [
      set nb one-of neighbors   
    ]
    
    face nb
    forward 1 
    
    set last-random-heading heading    
  ] 
  
end


to change-direction
  
  ifelse patch-ahead 1 != nobody and [patch-state] of patch-ahead 1 != "WALL" [
      forward 1   
    ]
    [
      set last-random-heading 361      
    ]  
  
end



to person-detect-event
  
  let detect-event false
  
  ask patches in-radius person-detection-radius [
    
    if patch-state = "EVENT" or patch-state = "EVENT_DONE" [
      
      set detect-event true
      
    ]
    
  ]
  
  if detect-event [
    
    person-state "EVENT_DETECTED"
    
  ]
  
end


to person-notify-neighbors
  
  if state = "EVENT_DETECTED" [
    
    ;; Broadcast (BasicFlooding) der event Detektion zur Warnung der anderen Personen
    broadcast ["EVENT_DETECTED"]
    
    person-state "FLEEING"    
  ]
  
end


to person-flee
  
  if state = "FLEEING" [
    
    ;; Broadcast (BasicFlooding) der event Detektion zur Warnung der anderen Personen
    broadcast ["EVENT_DETECTED"]
    
    person-move-to-exit
    
  ]
  
end


to person-move-to-exit
  
  let g random-float 1.00000001 ;; Wahrscheinlichkeit g
  let probability    0.00000001 ;; float initialisieren ?!
  set probability ( walk-propability / 100 )
  
  if g <= probability [
    
    let direction one-of neighbors   
    let this-noise [signal-noise] of patch-here    
    
    ifelse this-noise != 0 [ ;; Fallunterscheidung: Zellulärer Automat (Patches mit signal-noise != -1) ?
      
      foreach sort neighbors [
        
        if [patch-state] of ? != "WALL" and [patch-state] of ? != "EVENT" and [patch-state] of ? != "EVENT_DONE" [
          
          if [signal-noise] of ? < this-noise [          
            set direction ?
            face direction           
          ]
          
        ]      
      ] 
      
    ][ ;; Keine Patchinformation    
    
    ifelse orientation-algorithm = "Gradient localization" [ ;; Orientierung über die "Gradient localization" ?      
       
      if [patch-state] of patch-here != "WALL" [
        
        
        ;; TODO Wie den Exit lokalisieren?      
        let exit array:item exit-positions nearest-exit-of-person self 
        
        let x first exit
        let y last exit
        
        facexy x y
       
      ]
      
     
    ] 
    [
      
      random-walk 
      
    ]
    
    ]
    
    
    forward 1    
    
  ]  
  
  ;; Person kommt in Kontakt mit dem Giftgas und stirbt
  if [patch-state] of patch-here = "EVENT" or [patch-state] of patch-here = "EVENT-DONE"[
    
    person-state("DEAD")
    
  ]
  
end


to person-reach-exit
  
  let rescue false
  
  ask patch-here [
    
    let my-x pxcor
    let my-y pycor
    
    ask exits [
      
      if (my-x = xcor and my-y = ycor) [
        set rescue true
      ]
      
    ]
    
  ]
  
  if rescue [
    
    person-state "RESCUED"
    
  ]
  
end
