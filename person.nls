;; Person

persons-own [
  state ;; Status im Lebenszyklus
  messages
  parent 
  children 
  msgsent 
  msgrecv 
  msghear
  exit-hopcounts
  exit-positions
  est-pos
]

to person-state [newstate]
  
  set state newstate
  
  ;; Start
  if state = "INIT" [
    set size 15
    set shape "person"
    set color brown
    set heading 0
    set label-color black    
    set exit-hopcounts array:from-list n-values 2 [-1]
    set exit-positions array:from-list n-values 2 [-1]
  ]
  
  if state = "EVENT_DETECTED" [
    set label "!"
  ]  
  
  if state = "FLEEING" [
    set label "*"
  ]  
  
  ;; Ende
  if state = "RESCUED" [
    die ;; turtle von der Karte entfernen
  ] 
  
  if state = "DEAD" [
    set color grey    
    set shape "person_dead" ;; selbsterstellte Shape: rotierbar
    set heading 45
    set label "" 
    check-connection   
  ]
  
end


;; Zufällige Platzierung von Personen
to setup-persons
  
  if inputFile = "Abstract.png" [ ;; Zufällige Platzierung
    create-persons personCount [setxy random-pxcor random-pycor]
  ]
  if inputFile = "Simple.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ]
  if inputFile = "ikg.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ]
  if inputFile = "Raumplan.png" [ ;; Zufällige Platzierung mit Wand-Detektion
    place-persons
  ] 
  
  ;; Verlinkung aller Personen, Kommunikation wird per Distance eingeschränkt
  create-graph
  
  ask persons [
    
    set messages[] ;; Clear any messages
    set msgsent [] ;; Clear the list of messages sent
    set msgrecv [] ;; Clear the list of messages received
    set msghear []
    
    person-state("INIT")
  ]
  
end

to create-graph
  
  if graph-type = "Complete Graph" [
    createCompleteGraph
  ]
  
  if graph-type = "UDG" [
    createUDG
  ]
  
  if graph-type = "Fixed UDG" [
    createFixedUDG
  ]
  
  if graph-type = "RNG" [
    createRNG
  ]
  
  if graph-type = "GG" [
    createGG
  ]    
  
end

to place-persons
  
  create-persons personCount [
    
    let y random-pycor
    let x random-pxcor
    
    while [[pcolor] of patch x y != white] [
      
      set y random-pycor
      set x random-pxcor
      
    ]
    
    setxy x y 
    
  ]
  
end


to random-move
  
  ;; Erhalten der Broadcast Meldung, dass ein event detektiert wurde
  let msg received "EVENT_DETECTED"
  if msg != [] [
    broadcast ["EVENT_DETECTED"]
    ask link-neighbors [ask link-with myself [set color orange]] ;; Link colors are orange
    person-state "EVENT_DETECTED"
    stop
  ]
  
  
  let g random-float 1.00000001 ;; Wahrscheinlichkeit g
  let probability    0.00000001 ;; float initialisieren ?!
  set probability ( walk-propability / 100 )
  
  if g <= probability [
    
    let nb one-of neighbors
    
    while [[patch-state] of nb = "WALL"] [
      set nb one-of neighbors   
    ]
    
    face nb
    forward 1
    
    check-connection
    
  ]  
  
  ;; Person kommt in Kontakt mit dem Giftgas und stirbt
  if [patch-state] of patch-here = "EVENT" or [patch-state] of patch-here = "EVENT-DONE"[
    
    person-state("DEAD")
    
  ]
  
end

to person-detect-event
  
  let detect-event false
  
  ask patches in-radius person-detection-radius [
    
    if patch-state = "EVENT" or patch-state = "EVENT_DONE" [
      
      set detect-event true
      
    ]
    
  ]
  
  if detect-event [
    
    person-state "EVENT_DETECTED"
    
  ]
  
end


to person-notify-neighbors
  
  if state = "EVENT_DETECTED" [
    
    ;; Broadcast (BasicFlooding) der event Detektion zur Warnung der anderen Personen
    broadcast ["EVENT_DETECTED"]
    
    person-state "FLEEING"    
  ]
  
end


to person-flee
  
  if state = "FLEEING" [
    
    ;; Broadcast (BasicFlooding) der event Detektion zur Warnung der anderen Personen
    broadcast ["EVENT_DETECTED"]
    
    person-move-to-exit
    
  ]
  
end


to person-move-to-exit
  
  let g random-float 1.00000001 ;; Wahrscheinlichkeit g
  let probability    0.00000001 ;; float initialisieren ?!
  set probability ( walk-propability / 100 )
  
  if g <= probability [
    
    let direction one-of neighbors
    ;let min-noise exit-signal-strength + 1 ;; min auf maximalen wert + 1 gesetzt
    let this-noise [signal-noise] of patch-here
    
    foreach sort neighbors [
      
      if [patch-state] of ? != "WALL" and [patch-state] of ? != "EVENT" and [patch-state] of ? != "EVENT_DONE" [
        
        if [signal-noise] of ? < this-noise [          
          set direction ?
        ]
        
        ;if [signal-noise] of ? < min-noise [
        ;  set min-noise [signal-noise] of ?
        ;  set direction ?
        ;]
      ]      
    ]  
    
    face direction
    forward 1
    
    check-connection
  ]  
  
  ;; Person kommt in Kontakt mit dem Giftgas und stirbt
  if [patch-state] of patch-here = "EVENT" or [patch-state] of patch-here = "EVENT-DONE"[
    
    person-state("DEAD")
    
  ]
  
end


to person-reach-exit
  
  let rescue false
  
  ask patch-here [
    
    let my-x pxcor
    let my-y pycor
    
    ask exits [
      
      if (my-x = xcor and my-y = ycor) [
        set rescue true
      ]
      
    ]
    
  ]
  
  if rescue [
    
    person-state "RESCUED"
    
  ]
  
end



to check-connection
  
  let me self
  
  ask link-neighbors [ 
    
    ifelse state != "DEAD" and [state] of me != "DEAD" [
      
      ifelse distance myself <= person-detection-radius [ 
        
        ask link-with me [
          set shape "connect"
          set color blue
          show-link
        ]
        
      ][
      
      ask link-with me [
        set shape "communication"
        set color grey
        hide-link
      ]
      
      ]                
    ][
    
    ask link-with me [
      set shape "communication"
      set color grey
      hide-link
    ]
    
    ]
    
    
    ;if state = "DEAD" or [state] of me = "DEAD" [
    
    ; ask link-with me [
    ;  set shape "communication"
    ;  set color grey
    ;]
    
    ;]
    
  ]
  
end